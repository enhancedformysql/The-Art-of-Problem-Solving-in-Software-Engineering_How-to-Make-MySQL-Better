## 4.8 性能优化

优化代码性能需要逻辑推理。程序员必须分析效率、评估权衡并做出明智的决策以提高性能。这有助于识别瓶颈、优化算法和有效使用资源[56]。低效的代码序列或性能错误会导致严重的性能下降和资源浪费，降低吞吐量、增加延迟并使用户感到沮丧，导致经济损失。诊断这些错误具有挑战性，因为它们具有非故障停止症状，通常需要数月的专家努力[62]。

### 4.8.1 性能优化流程图

对于性能优化，该过程可以简化为以下流程图[40]：

![](media/068e498c1a257071ce3004ad2d7b7ee3.png)

图 4-49. 性能优化流程图。

在评估新的性能优化功能时，首先在 SMP 环境中测试其影响。如果在 SMP 环境中没有改进，但在 NUMA 环境中有整体改进，则该功能可能与可扩展性有关。进行理论分析以了解改进机制。如果可以从理论上解释，则优化是有效的；如果不能，则可能是无效的。如果功能没有提高性能，通过广泛的测试和比较寻找新的优化机会。性能的提升和损失都可以揭示潜在的优化领域。例如，如果新的内存分配工具导致性能下降，这表明其具有重大影响，需要找到最佳工具。在识别出重大优化机会后，评估权衡以确定最佳方法。例如，如果 PGO 在高并发下降低吞吐量，这就提供了一个优化机会。解决方案可能包括通过更好的数据结构和算法减少关键部分的处理时间，或完全消除闩锁，这涉及大量的代码修改和复杂的逻辑，使维护具有挑战性。

如果仍未捕获优化机会，可能需要重新设计。例如，Group Replication 采用基于"木桶原理"的架构，如下图所示：

![](media/207ecb2302928ddf7ea58a6421ded46b.png)

图 4-50. "木桶原理"示意图。

"木桶原理"是指由多块木板组成的木桶，其能容纳的水量由最短的木板决定，而不是最长的。对于 Group Replication，根据"木桶原理"，性能由集群中最慢的节点决定，通常导致性能不如半同步复制。在不改变设计的情况下，找到优化点变得困难。因此，需要重新设计 Group Replication 以完全解决基于"木桶原理"的认证数据库固有的性能缺陷。

### 4.8.2 吞吐量与响应时间

吞吐量和响应时间具有通常是倒数但微妙复杂的关系[33]。吞吐量侧重于资源利用，检查服务器资源如何有效处理任务。响应时间强调用户请求的响应性，影响用户体验。

在性能优化中，两个主要目标是：

1. **最佳响应时间：** 最小化等待任务完成的时间。
2. **最大吞吐量：** 尽可能处理尽可能多的同时任务。

这些目标是矛盾的：优化响应时间需要最小化系统负载，而优化吞吐量需要最大化负载。平衡这些相互冲突的目标是有效性能优化的关键。

使用 SysBench 工具分析 MySQL 半同步吞吐量与并发之间的关系，如下图所示，提供了这些指标在测试环境中如何相互作用的见解。

<img src="media/image-20240829084841772.png" alt="image-20240829084841772" style="zoom:150%;" />

图 4-51. 使用 SysBench 的半同步吞吐量与并发关系。

图表显示吞吐量在 500 并发时达到峰值。同样，后续图表表明响应时间也在 500 并发时达到峰值。

<img src="media/image-20240829084901737.png" alt="image-20240829084901737" style="zoom:150%;" />

图 4-52. 使用 SysBench 的半同步响应时间与并发关系。

观察到高吞吐量伴随着高响应时间是很常见的。随着计算资源的增加，资源利用效率可能会降低，吞吐量仍可能逐渐增加。在不考虑质量和效率的情况下追求更高的吞吐量是短视的。相反，找到响应时间和吞吐量之间的最佳平衡至关重要。

这个平衡点，称为"拐点"，代表最佳负载水平，其中吞吐量最大化，对响应时间的负面影响最小。对于处理随机定时服务请求的系统，超过拐点值可能会由于负载的微小变化而导致响应时间和吞吐量的严重波动。因此，管理负载以保持在拐点值以下至关重要[33]。

对于上述半同步测试，吞吐量和响应时间在 100 并发时都很好。实施事务节流机制可以有效地将 MySQL 的最大并发事务限制为 100。

### 4.8.3 阿姆达尔定律

在计算机体系结构中，阿姆达尔定律提供了一个公式，用于预测在系统资源改进时具有固定工作负载的任务的延迟的理论加速[45]。

尽管阿姆达尔定律在理论上成立，但它在 MySQL 的实际性能改进过程中往往难以解释某些现象。例如，同一程序在 SMP 环境中显示 10% 的改进，但在 NUMA 环境中显示 50% 的改进。在 SMP 环境中进行了测量，优化部分占执行时间的 20%，通过算法改进提高了 2 倍。根据阿姆达尔定律，理论改进应计算如下：

![image-20240902000000003](media/image-20240902000000003.png)

在实践中，SMP 环境中的 10% 改进与理论预期一致。然而，NUMA 环境中的 50% 改进显著超过这些预测。这种差异不是由于理论缺陷或错误，而是因为 NUMA 环境中的性能改进不能直接与 SMP 环境中的性能改进进行比较。阿姆达尔定律严格适用于同一环境。

准确的测量数据也很难获得[11]。开发人员通常使用 *perf* 等工具来识别瓶颈。*perf* 显示的瓶颈越大，改进的潜力就越大。然而，一些瓶颈是分布式或分散的，使用 *perf* 很难精确定位它们，因此很难识别优化机会。例如，配置文件引导优化（PGO）可能不会在 *perf* 中突出导致性能不佳的特定瓶颈，但 PGO 仍然可以显著提高性能。

以 MVCC ReadView 数据结构的优化为例说明了工具在统计测量中的挑战。如下图所示，此优化在高并发场景下显示了吞吐量的实质性改进。

<img src="media/image-20240829085005983.png" alt="image-20240829085005983" style="zoom:150%;" />

图 4-53. 采用新混合数据结构前后的性能比较。

让我们继续分析在 300 并发下优化 MVCC ReadView 数据结构之前的 *perf* 统计信息，如下图所示

![](media/22ed76b816248d0b27456d03e85bcea4.png)

图 4-54. 优化 MVCC ReadView 数据结构之前的 *perf* 统计信息。

*Perf* 分析显示，第一和第二个瓶颈合计约占总数的 33%。在优化 MVCC ReadView 后，这个百分比降至约 5.7%，反映了约 28% 的减少，考虑到测量波动，最多可达 30%。根据阿姆达尔定律，理论性能改进可达约 43%。然而，实际吞吐量增加了 53%。

![](media/440f78c946a7e68fece427a41d414a2d.gif)

![](media/d06602b60d3af269409eb5633f8387c5.png)

图 4-55. 优化 MVCC ReadView 数据结构之后的 *perf* 统计信息。

基于广泛的测试，得出结论：差异的根本原因在于 *perf* 统计的固有不准确性。阿姆达尔定律本身在理想条件下不会引起误解。然而，由于测量误差和人为错误，应用此定律直接评估性能改进需要谨慎。此外，阿姆达尔定律可能会随着环境的变化而变化。

### 4.8.4 性能建模

MySQL 的复杂性使性能建模具有挑战性，但专注于特定子系统可以为性能问题提供有价值的见解。例如，在对 MySQL 5.7 中的主要闩锁进行性能建模时，发现执行事务（事务隔离级别为 Read Committed）涉及某些操作：

- **读操作：** 通过 trx-sys 子系统，可能涉及全局闩锁排队。
- **写操作：** 通过 lock-sys 子系统，涉及锁调度的全局闩锁排队。
- **Redo Log 操作：** 写操作需要更新 redo log 子系统，这也涉及全局闩锁排队。

![](media/197c7662d3b25ebbc2870a1cee917e3f.png)

图 4-56. MySQL 5.7 中的闩锁队列模型。

在 MySQL 5.7 中，可扩展性差主要是由于 **trx-sys**、**lock-sys** 和 **redo log** 子系统之间激烈的全局闩锁竞争。例如，TPC-C 性能测试（如下图所示）揭示了可扩展性差。

<img src="media/image-20240829085045336.png" alt="image-20240829085045336" style="zoom:150%;" />

图 4-57. MySQL 5.7.39 在 BenchmarkSQL 测试期间的可扩展性问题。

### 4.8.5 性能分析工具局限性的挑战

当面对程序中的性能问题时，典型的方法是使用分析器来识别热方法并优化它们以提高性能。如果没有实现预期的改进，通常的嫌疑人是糟糕的内存系统交互或硬件误解，但很少质疑分析器[12]。

传统观点认为，PMU 采样为热过程（具有更多样本的过程）提供更可靠的结果，而较冷的过程（样本较少的过程）往往更嘈杂。这种差异是由于 PMU 溢出中断和信号传递到性能工具之间的固有延迟或"偏移"。这个问题在各种架构中普遍存在，包括 x86 和 ARM，是测量不准确的重要来源。在乱序处理器中，PMU 计数器溢出中断的延迟可能特别明显[11]。

仅靠分析可能不足以确定性能问题的根本原因，特别是那些具有复杂传播或在函数边界浪费计算时间的问题。因此，应该战略性地使用性能工具：当识别出明确的瓶颈时，应进行深入分析以解决它。然而，缺乏明显的瓶颈并不排除潜在问题的存在；可能需要替代方法来揭示它们。

例如，配置文件引导优化（PGO）可能不会在 *perf* 工具中突出优化机会，但它仍然可以通过全面优化计算代码来实现显著的性能提升。同样，trx-sys 子系统可能由于设计不佳的数据结构延长关键部分持续时间而表现出严重的闩锁瓶颈。这个问题最初源于数据结构设计，可能会升级为激烈的闩锁竞争，产生级联效应。

### 4.8.6 缓解可扩展性问题

饱和的闩锁会降低多线程应用程序性能，导致可扩展性崩溃，特别是在超额订阅系统（线程多于硬件核心）上。随着线程在饱和闩锁中循环，由于对计算核心和最后一级缓存（LLC）等共享系统资源的竞争，整体性能会逐渐消退或突然下降。线程增加导致缓存压力、缓存未命中以及等待线程消耗资源，进一步加剧竞争。

为了解决这些可扩展性问题，请考虑以下措施：

- 提高关键资源访问速度。
- 使用闩锁分片来减少冲突。
- 最小化不必要的唤醒过程。
- 实现无闩锁机制。
- 仔细设计架构。
- 实现事务节流机制。

#### 4.8.6.1 提高关键资源访问速度

使用混合数据结构来改进 MVCC ReadView 减少了在关键部分花费的时间，显著提高了 MySQL 在 NUMA 环境中的可扩展性。图 4.10 表明，加速 trx-sys 内关键部分的访问显著增加了 NUMA 环境中的高并发吞吐量。

#### 4.8.6.2 闩锁分片以减少闩锁冲突

在 MySQL 8.0 中，为 lock-sys 实现了闩锁分片，以减少锁调度子系统中的闩锁开销。下图比较了此改进前后的性能

<img src="media/image-20240829085119472.png" alt="image-20240829085119472" style="zoom:150%;" />

图 4-58. lock-sys 优化前后的 BenchmarkSQL 测试比较。

#### 4.8.6.3 最小化不必要的唤醒过程

Binlog 组提交采用低效的激活机制，导致类似于惊群问题的问题。当所有等待线程被激活时，只有一部分继续处理，而其他线程继续等待。这导致许多不必要的线程被激活，造成大量 CPU 资源浪费。

下图显示了优化 binlog 组提交前后的吞吐量比较：

<img src="media/image-20240829085146797.png" alt="image-20240829085146797" style="zoom:150%;" />

图 4-59. innodb_thread_concurrency=128 时组提交优化的影响。

从图中可以看出，优化此激活机制在高并发条件下明显提高了吞吐量。有关更详细的信息，请参阅第 8.1.2 节。

#### 4.8.6.4 无闩锁处理

MySQL redo log 优化使用无闩锁处理来显著增强 redo log 的可扩展性，并大大提高并发写入的性能。下图显示了 redo log 优化前后的 TPC-C 吞吐量比较。在低并发场景中有明显的改进。然而，在高并发情况下，吞吐量反而下降，主要是由于多队列瓶颈之间的相互干扰。

<img src="media/image-20240829085209463.png" alt="image-20240829085209463" style="zoom:150%;" />

图 4-60. redo log 优化前后的 BenchmarkSQL 测试比较。

有关更详细的信息，请参阅第 7.1.1 节。

#### 4.8.6.5 实现事务节流机制

这部分在第 8.3 章详细介绍。

#### 4.8.6.6 仔细设计架构

架构设计需要考虑长期需求，以避免未来困难的重新设计。例如，MySQL 从节点面临众多设计问题，在 NUMA 环境中性能不佳，并且因延迟中继日志文件处理的架构缺陷而受损。这些问题加上历史问题，使得改进 MySQL 从节点重放相当困难。

### 4.8.7 优化响应时间

只有在显著缓解可扩展性问题后，才能在高并发条件下有效减少用户请求的响应时间。以下是实现减少响应时间的方法。

#### 4.8.7.1 优化数据结构和算法

在解决性能瓶颈时，通常需要利用数据结构和算法的力量。在性能分析中，如果识别出源于数据结构的问题，可以通过基于数据特性进行优化来实现显著收益。这种优化往往相对简单；例如，优化 MVCC ReadView 数据结构是一个典型案例。

关于算法，在成熟的模块中通常很难找到优化机会。然而，在不太成熟的模块中，通常存在许多优化机会。例如，在 Group Replication 中，有很多算法改进的机会。两个经典示例包括优化 Paxos 算法和改进最后提交的重放计算中的搜索算法，这将在后续章节中详细介绍。

#### 4.8.7.2 强调缓存友好性

缓存对性能有重大影响，保持缓存友好性主要涉及以下原则：

1. **顺序内存访问：** 尽可能按顺序访问内存数据。顺序访问有利于缓存效率。例如，直接插入排序等算法在小数据集上运行，对缓存非常友好。
2. **确保代码对缓存友好**：频繁访问的函数是否内联，是否有阻碍内联的代码，以及是否适当使用 switch 语句——所有这些因素都会影响代码的缓存友好性。
3. **避免伪共享：** 伪共享发生在不同线程同时修改同一缓存行的部分时，导致频繁的缓存失效和性能下降。这通常发生在不同线程并发修改同一结构的不同成员时。

伪共享是多处理器系统中众所周知的问题，导致在此类环境中运行的多线程程序性能下降。下图显示了伪共享的示例。

![](media/1bb6230ef81aff3de4431206f0dbeed4.png)

图 4-61. 伪共享的示例。

线程 0 和 1 更新同一缓存行上彼此相邻的变量。虽然每个线程修改不同的变量，但每次迭代都会使缓存行失效。具体来说，当 CPU 1 写入新值时，它会使 CPU 0 的缓存失效，导致写回到主内存。同样，当 CPU 0 更新其变量时，它通过将 CPU 1 的缓存行写回主内存来使 CPU 1 的缓存失效。如果两个 CPU 反复向其变量写入新值，它们的缓存和主内存之间将发生不断的失效。这显著增加了主内存访问，并由于内存层次结构级别之间的数据传输的高延迟而导致大量延迟[36]。

在 MySQL 代码中，已经实施了特定的预防措施来解决缓存伪共享问题。例如，性能模式的缓存填充改进在以下 git 日志描述中详细说明。

```c++
commit 4d46b7560a4d91c85d10ef68ee349e4b1b4a7e17
Author: Marc Alff <marc.alff@oracle.com>
Date:   Fri Nov 8 20:58:48 2013 +0100
    Bug#17766582 PERFORMANCE SCHEMA OVERHEAD IN PFS_LOCK

    This fix is a general cleanup for code involving atomic operations in the
    performance schema, to reduce overhead and improve code clarity.

    Changes implemented:
    ...
    Added missing PFS_cacheline_uint32 to atomic counters,
    to enforce no false sharing happens.

    This is a performance improvement.
```

删除这些缓存填充优化，如下图所示，作为缓存优化之前的版本。

![](media/9a737b0274b3fad6b6d2570bba64996a.gif)

图 4-62. 部分回退缓存填充优化。

比较缓存优化前后的性能以确定是否存在明显差异。为了获得准确的结果，应在测试期间启用性能模式启动 MySQL。

<img src="media/image-20240829085254141.png" alt="image-20240829085254141" style="zoom:150%;" />

图 4-63. 缓存优化前后的 BenchmarkSQL 测试比较。

从图中可以明显看出，缓存填充优化在低并发条件下显示出最小的影响，但在高并发下确实有影响。值得注意的是，MySQL 在多个地方实施了缓存填充优化，累积的性能改进可能是显著的。

#### 4.8.7.3 PGO

这部分在第 11.1 章详细介绍。

#### 4.8.7.4 使用更好的内存分配工具

在 NUMA 环境中，有效的内存分配工具对性能至关重要，无论是对于 MySQL 主节点还是从节点。有关更详细的信息，请参阅第 11.3 节。

#### 4.8.7.5 减少网络延迟

有关更详细的信息，请参阅第 4.7.6 节。

#### 4.8.7.6 总结

为了优化响应时间，不仅可以采用上述讨论的通用技术，还可以进行特定于业务的优化。例如，对于 MySQL，优化索引可以减少响应时间。有关此的详细信息可以在下一章中找到。

### 4.8.8 响应时间的尾部行为：SLA 的挑战

另一个重要的指标是响应时间的尾部行为，定义为响应时间超过某个级别 x 的概率，或 P{T \> x}。理解这种行为对于设置服务级别协议（SLA）至关重要，公司可能会确保响应时间以 95% 的概率保持在 x 以下。不幸的是，推导尾部行为通常很困难[10]。

在非常高的百分位数下减少响应时间具有挑战性，因为它们很容易受到您无法控制的随机事件的影响，并且收益正在递减。排队延迟对高百分位数响应时间有显著贡献。服务器的有限并行处理能力（例如，受 CPU 核心限制）意味着几个慢请求可以阻止后续请求，导致队头阻塞。即使后续请求很快，由于等待，客户端也会觉得它们很慢。因此，在客户端测量响应时间至关重要。

### 4.8.9 NUMA 系统中的性能问题

NUMA 架构通常用于多插槽系统以扩展内存带宽。然而，如果没有 NUMA 感知设计，程序可能会由于插槽间带宽争用而经历显著的性能下降[12]。

MySQL 在 NUMA 环境中性能不佳：具有 Read Committed 隔离级别的事务受损，MySQL 从节点重放受到激烈闩锁竞争的严重影响。这些问题将在后续章节中解决。

### 4.8.10 性能提升并非总是累加的

性能优化很复杂；各种优化的改进不是简单地累加的。除了第 4.7.5 节讨论的非累加性能案例外，这里还有一个额外的示例。下图显示了在优化 MVCC ReadView 之前，将 MySQL spin delay 设置为 20 时 MySQL 的性能改进。在高并发条件下吞吐量显著增加。

<img src="media/image-20240829085727776.png" alt="image-20240829085727776" style="zoom:150%;" />

图 4-64. spin delay 优化前后的 BenchmarkSQL 测试比较。

这是 MVCC ReadView 优化本身的改进，如下图所示。可以看出，在高并发条件下吞吐量有更明显的增加。

<img src="media/image-20240829085852775.png" alt="image-20240829085852775" style="zoom:150%;" />

图 4-65. MVCC 优化前后的 BenchmarkSQL 测试比较。

下图说明了这两种优化对 TPC-C 吞吐量随并发增加的综合影响。

<img src="media/image-20240829085935810.png" alt="image-20240829085935810" style="zoom:150%;" />

图 4-66. 结合 MVCC 改进的 spin delay 优化前后的 BenchmarkSQL 测试比较。

从图中可以观察到，将 MySQL spin delay 参数设置为 20 后，吞吐量与默认 MySQL spin delay 为 6 时相似。MySQL spin delay 参数使用忙等待来减少关键部分中的线程 NUMA 跨节点切换。由于 MVCC ReadView 优化减少了关键部分中 NUMA 跨节点切换的机会，MySQL spin delay 参数的效果自然减弱。

[下一页](Chapter4_9_zh.md)

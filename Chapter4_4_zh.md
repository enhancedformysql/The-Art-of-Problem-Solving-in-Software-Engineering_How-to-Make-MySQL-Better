# 4.4 操作系统

操作系统(OS)是管理计算机硬件和软件资源并为计算机程序提供通用服务的系统软件 [45]。

MySQL 主要部署在 Linux 操作系统上。为了保持专注,这里的讨论基于 Linux 操作系统环境中的场景。这包括 CPU 调度、进程和线程模型、阶段模型、内存分配和系统调用,所有这些都与 MySQL 性能密切相关。

## 4.4.1 CPU 调度

在操作系统中将 CPU 时间分配给不同任务的工作称为 CPU 调度。Linux CPU 的组织结构如下图所示 [53]。

![](media/f06f930419cee402a7a5cac1de4b1557.png)

图 4-15. Linux CPU 调度。

基于物理核心的硬件布局,Linux 调度器维护分层有序的调度域。基本调度域由运行在物理相邻核心上的进程组成,例如同一芯片上的核心。更高级别的调度域对这些基本域进行分组,例如同一主板上的芯片。

Linux 调度器作为多队列调度器运行,这意味着每个逻辑主机 CPU 都有自己的等待执行的进程运行队列。每个虚拟 CPU 在这些运行队列之一中排队。将虚拟 CPU 从一个运行队列移动到另一个称为 CPU 迁移。当估计等待时间过长、当前运行队列已满或另一个运行队列需要填充时,调度器可能决定迁移虚拟 CPU。

由于核心之间缓存的接近性,在同一调度域内迁移虚拟 CPU 的成本比将其移动到不同域的成本要低。Linux 调度器使用有关不同调度域或 CPU 之间迁移成本的详细信息来确定迁移是否有益。

理解 CPU 调度细节对于诊断 MySQL 性能问题至关重要。一个关键问题是 Linux 的调度机制能否有效管理 MySQL 中数千个并发线程。由于 MySQL 基于线程模型运行,因此评估 Linux 调度器如何处理如此大量的线程非常重要。它是否简单地在它们之间平均分配 CPU 时间?

考虑一个有 *N* 个用户线程和 *C* 个 CPU 核心的场景,每个核心支持双超线程。理想情况下,不考虑上下文切换开销,每个用户线程每秒应该接收以下 CPU 执行时间。

![image-20240902000000002](media/image-20240902000000002.png)

随着 *N* 的增加,每个线程的平均 CPU 分配减少。例如,如果 *N=100000* 且 *C=3*,每个线程每秒只能接收约 60 微秒的 CPU 时间。鉴于上下文切换通常会产生数十微秒范围内的成本,大量 CPU 时间将丢失给上下文切换,从而降低整体 CPU 效率。

随着用户线程数量的增加,Linux 调度器难以有效管理 CPU 时间,导致由于频繁的上下文切换而效率低下和性能下降。为了解决这个问题,系统强制执行最小执行粒度,确保每个进程在被抢占之前至少运行 100 微秒。这种方法最大限度地减少了短调度间隔的低效率。完全公平调度器(CFS)使用这个最小粒度来防止随着可运行进程数量的增长而导致的过度切换成本。

同时,增加 CPU 核心数量确保每个用户线程接收足够的执行时间。再加上保持最小执行粒度,可以显著缓解上下文切换的成本。

接下来,让我们检查线程阻塞的成本。阻塞的缺点是上下文切换的成本——通常为 12-20 微秒——必须每次锁移交执行两次(一次睡眠,再次唤醒)[3]。一般来说,在保持最小执行时间的条件下,与当前主流硬件环境相比,上下文切换的成本已经相当小。因此,采用阻塞方法具有实用价值。

进一步检查 Linux CPU 如何为运行程序调度线程,具体细节见下图:

![](media/b4acd55e80fa396e2883b6968d5189e1.png)

图 4-16. Linux CPU 如何为运行程序调度线程。

数字越小,优先级越高。调度器优先处理优先级较高的线程,线程的时间片到期后,它被放入"过期"队列。

MySQL 内部线程可以处于不同的状态,例如运行、等待 I/O 或等待锁。等待磁盘 I/O 的线程被放入相应的磁盘等待队列,并且不会被 Linux 调度器调度到活动或过期队列中。

![](media/a4bdf21cfdcad9b691198fa2486eaeb8.png)

图 4-17. 等待 I/O 的线程的 Linux CPU 调度。

这意味着这些等待 I/O 的线程对其他活动线程的影响很小。在 MySQL 中,事务锁等待的功能类似于 I/O 等待——线程自愿阻塞自己并等待被激活,在冲突不严重的情况下通常是可管理的。

值得一提的是,应该避免让大量线程等待同一个全局锁存器或锁,因为这可能导致频繁的上下文切换。在 NUMA 环境中,它还可能导致频繁的缓存迁移 [71],从而影响 MySQL 的可扩展性。

随着当今可用的 CPU 核心数量和更大的内存大小的增加,线程创建成本对 MySQL 的影响已经变小。除了短连接应用程序等特殊场景外,如果有足够的内存,MySQL 可以处理大量线程。关键是限制同时运行的活动线程数量。理论上,MySQL 可以支持数千个并发线程。

使用 CPU 调度原理,MySQL 实现了事务节流机制,例如限制进入 InnoDB 事务系统的线程数量。这确保了事务的并发性保持可管理。太多线程进入 InnoDB 会导致锁存器争用,显著降低效率。

下图展示了使用事务节流机制将进入 InnoDB 存储引擎的最大线程数限制为 512,描绘了从 50 到 10,000 并发的 MySQL 单实例吞吐量。

<img src="media/image-20240829083740371.png" alt="image-20240829083740371" style="zoom:150%;" />

图 4-18. 使用事务节流机制的 BenchmarkSQL 中的最大 TPC-C 吞吐量。

如图所示,即使在 10,000 并发时,TPC-C 吞吐量也超过 800,000 tpmC,与峰值仅略有下降。

## 4.4.2 进程模型

在 Linux 中,进程和线程是多任务处理和并行执行的基础。进程是具有自己内存空间的独立执行单元,而线程是进程内的较小执行单元,共享其内存空间。

**主要区别包括:**

- **内存消耗:** 进程需要单独的内存空间,与共享父进程内存的线程相比,它们的内存密集度更高。进程通常消耗约 10 兆字节,而线程使用约 1 兆字节。
- **并发处理:** 在相同的内存量下,系统可以支持比进程多得多的线程。这使得线程更适合需要高并发的应用程序。

在构建并发数据库系统时,内存效率至关重要。MySQL 使用基于线程的模型相对于传统 PostgreSQL 的基于进程的模型提供了优势,特别是在高并发场景中。虽然 PostgreSQL 的模型可能导致更高的内存消耗,但 MySQL 的线程模型在处理大量并发连接方面更有效率。

此外,尽管 Nginx 使用多进程模型,但它通过异步编程技术实现可扩展性。

## 4.4.3 线程模型

对于 MySQL 来说,基于线程的模型相对于进程模型具有优势,因为其理论上支持数万个并发线程。然而,论文"A Case for Staged Database Systems"强调了这种模型的一些缺点 [21]。

**基于线程模型的挑战:**

1. **缓存性能:** 基于线程的执行模型在有多个客户端时通常导致较差的缓存性能。
2. **复杂性:** 现代 DBMS 软件的单片设计导致复杂、难以维护的系统。

**基于线程并发的陷阱:**

1. **线程管理:** 对于不同的工作负载,没有最优的预分配工作线程数量。太多的线程会浪费资源,而太少会限制并发性。
2. **上下文切换:** 操作期间的上下文切换可能会从缓存中驱逐大量工作集,导致线程恢复时的延迟。
3. **缓存利用率:** 循环调度不考虑共享缓存内容的好处,导致效率低下。

尽管操作系统在不断改进,但线程模型在优化方面仍然面临重大挑战。

在 MySQL 中,当大量线程进入 InnoDB 事务系统时会出现一个重大问题。这增加了锁存器争用并扩展了 MVCC ReadView 全局活动事务列表,导致频繁的缓存迁移。这个问题在超高并发场景中尤其明显。例如,下图显示了在 10ms 延迟的网络环境中 Group Replication 吞吐量如何随并发度变化。

<img src="media/image-20240829083807720.png" alt="image-20240829083807720" style="zoom:150%;" />

图 4-19. 10ms 网络延迟下 Group Replication 的最大线程可扩展性。

在 5000 并发时,吞吐量保持相对稳定。然而,超过这一点,吞吐量急剧下降。在极高并发场景中,严重的锁存器冲突和频繁的缓存迁移显著降低了 MySQL 的效率。

## 4.4.4 阶段模型

阶段模型是一种专门类型的线程模型,它最大限度地减少了与处理大量并发线程相关的一些缺点。这种模型涉及将数据库系统分解为不同的模块,每个模块都封装到通过队列互连的自包含阶段中。通过解决硬件和软件挑战,阶段模型为传统 DBMS 设计的限制提供了有效的解决方案 [21]。

**阶段模型的好处**

1. **针对性的线程分配**: 每个阶段根据其特定功能和 I/O 频率分配工作线程,而不是根据并发客户端的数量。与通用线程池大小相比,这种方法允许针对不同数据库任务的需求进行更精确的线程管理。
2. **自愿线程让出**: 与任意抢占线程不同,阶段线程在其阶段代码执行结束时自愿让出 CPU。这减少了工作集收缩阶段的缓存驱逐,最大限度地减少了恢复它所需的时间。这种技术也可以适应现有的数据库架构。
3. **利用阶段亲和力**: 线程调度器专注于同一阶段内的任务,这有助于利用处理器缓存亲和力。初始任务将公共数据结构和代码带入更高的缓存级别,减少后续任务的缓存未命中。
4. **CPU 绑定效率**: 阶段模型中线程操作的单一性质允许通过 CPU 绑定提高效率,这在 NUMA 环境中特别有效。

阶段模型在 MySQL 中广泛用于诸如从节点重放、Group Replication 和 MySQL 8.0 中 Redo 日志改进等任务。然而,由于各种队列导致响应时间增加,它不太适合处理用户请求。MySQL 主服务器优先考虑面向用户的操作的低延迟和高吞吐量,而像从节点重放这样不直接与用户交互的任务可以以更高的延迟换取高吞吐量。

下图展示了 Group Replication 的处理流程。在这个设计中,Group Replication 被划分为通过队列连接的多个子进程。这种阶段方法提供了几个好处,包括:

- **高效性**: 通过将任务分解为离散的阶段,Group Replication 可以更有效地处理任务。
- **缓存友好访问**: 该设计通过确保相关任务按顺序执行来最大限度地减少缓存未命中。
- **流水线处理**: 以流水线方式处理任务,从而提高吞吐量

![](media/7759809055f85565e4bafedef312acc0.png)

图 4-20. MySQL Group Replication 协议。

在阶段模型中,当处理大量数据时,使用单个线程可能成为瓶颈。例如,在图中显示的应用重放过程中,线程负责 CPU 密集型任务(如读取和解码中继日志)以及调度和协调。这可能会显著妨碍 MySQL 从节点重放的性能,限制其高效快速处理数据的能力。

## 4.4.5 内存分配

Linux 内存管理子系统监督虚拟内存、需求分页以及内核结构和用户程序的内存分配。内存热点通常源于不当的数据初始化 [4],特别是在默认的首次触摸策略下,这可能导致 NUMA 节点之间的内存分布不均。为了缓解这种情况,在将使用数据的计算分区中初始化数据。

现代 CPU 产生高内存请求率,可能会使互连或内存控制器不堪重负。NUMA 系统由于其众多的硬件线程,由于并发内存分配请求而面临可扩展性问题。解决方案包括覆盖内存分配器、定义线程放置和亲和方案以及调整操作系统配置。高效的内存分配器在 NUMA 系统中特别有益,在这些系统中,由于低效的内存或缓存使用而导致的性能惩罚可能很大。

Linux 优先考虑本地节点分配,并使用调度域最大限度地减少跨节点的线程迁移。这减少了跨域迁移,但可能影响负载平衡和性能。要优化内存使用:

1. 识别内存密集型线程。
2. 将它们分布在内存域中。
3. 与线程一起迁移内存。

理解这些内存管理原理对于诊断和解决 MySQL 性能问题至关重要。Linux 旨在通过最大限度地减少 CPU 切换和跨 NUMA 节点的缓存迁移来减少进程干扰。

下图展示了一个比较实验。深蓝色曲线显示了在 NUMA 系统上运行四个 MySQL 实例而不进行节点绑定时的总吞吐量。相比之下,深红色曲线表示将每个 MySQL 实例绑定到不同 NUMA 节点时的总吞吐量。后一种设置反映了理想的吞吐量,因为它最大限度地减少了 MySQL 实例之间的 CPU 调度干扰。

<img src="media/image-20240829083858029.png" alt="image-20240829083858029" style="zoom:150%;" />

图 4-21. 比较多实例的理想 NUMA 调度与实际 Linux 调度。

根据图表,很明显,虽然操作系统在低并发下努力接近理想吞吐量,但随着并发度的增加,差距会扩大。这种差距的扩大是因为随着线程数量的增加,内存调度变得更加复杂。

对于 MySQL 应用程序来说,有效利用基于 NUMA 的内存分配至关重要。测试结果表明,对于 TPC-C 类型的工作负载,在 BIOS 级别禁用 NUMA 可以改善 MySQL 主服务器的吞吐量。这种改进是由于这种设置为 MySQL 主和类似应用程序提供了更有利的内存分配配置。

## 4.4.6 系统调用

传统上,系统调用的性能成本主要是由于模式切换时间。这个时间包括在用户模式下执行系统调用指令、转换到内核模式以及最终返回到用户模式。现代处理器将此模式切换作为处理器异常处理,这涉及刷新用户模式流水线、将寄存器保存到内核堆栈、更改保护域并将执行定向到异常处理程序。此后,需要从异常返回以恢复用户模式下的执行 [17]。

频繁的系统调用会显著影响 MySQL 的性能。例如,Percona 的线程池依赖于引入显著开销的系统调用,可能会减少线程池带来的一些性能增益。

[下一页](Chapter4_5_zh.md)

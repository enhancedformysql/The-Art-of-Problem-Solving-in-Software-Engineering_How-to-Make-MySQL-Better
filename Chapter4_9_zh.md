## 4.9 分布式理论

MySQL 集群作为分布式数据库运行，受 CAP 定理和一致性等分布式理论原则的约束。

### 4.9.1 CAP 定理

分布式数据库具有三个非常理想的属性：

1\. 对网络分区的容错性

2\. 一致性

3\. 可用性

CAP 定理指出：对于任何共享数据系统，您最多可以拥有这些属性中的两个

理论上有三个选择：

1. 放弃分区容错性

   系统在网络分区的情况下没有定义的行为。

2. 放弃一致性

   在分区的情况下，数据仍然可以使用，但由于节点无法相互通信，因此无法保证数据是一致的。

3. 放弃可用性

   数据只能在保证其一致性的情况下使用，这意味着需要悲观锁定。这需要锁定任何更新的对象，直到更新已传播到所有节点。在网络分区的情况下，数据库可能需要相当长的时间才能返回到一致状态，从而损害高可用性的保证。

在现实环境中放弃分区容错性是不可行的，因为网络分区是不可避免的。因此，有必要在可用性和一致性之间做出选择[20]。

CAP 定理的证明过程是逻辑推理的典型例子。具体的证明过程如下所述[20]：

```
首先 Gilbert 和 Lynch 定义了三个属性：

1. 一致性（原子数据对象）
必须存在所有操作的全序，以便每个操作看起来好像在单个实例完成。对于分布式共享内存，这意味着（除其他事项外）在写操作完成后发生的所有读操作必须返回此（或更高版本）写操作的值。

2. 可用性
非故障节点收到的每个请求都必须产生响应。这意味着服务使用的任何算法最终必须终止。

3. 分区容错性
允许网络丢失从一个节点发送到另一个节点的任意多条消息。

根据此定义，该定理通过反证法得到证明：

假设满足所有三个标准（原子性、可用性和分区容错性）。由于任何至少有两个节点的网络都可以分为两个不相交的非空集合 {G1,G2}，我们将网络定义为这样。原子对象 o 具有初始值 v0。我们将 a1 定义为执行的一部分，包括在 G1 中对原子对象进行单次写入值 v1 ≠ v0。假设 a1 是该时间段内唯一的客户端请求。此外，假设 G2 中未收到来自 G1 的消息，反之亦然。

由于可用性要求，我们知道 a1 将完成，这意味着对象 o 现在在 G1 中具有值 v1。

类似地，a2 是执行的一部分，包括在 G2 中对 o 进行单次读取。在 a2 期间，G1 中再次未收到来自 G2 的消息，反之亦然。由于可用性要求，我们知道 a2 将完成。

如果我们开始由 a1 和 a2 组成的执行，G2 只看到 a2，因为它没有收到关于 a1 的任何消息或请求。因此，来自 a2 的读取请求仍然必须返回值 v0。但是由于读取请求仅在写入请求结束后开始，因此违反了原子性要求，这证明了我们不能同时保证所有三个要求。证毕。
```

理解 CAP 定理为理解分布式系统中的问题奠定了基础。例如，在 Group Replication 集群中，在每个节点上实现强一致性可能需要牺牲可用性。Group Replication 的"after"机制可以满足此要求。相反，优先考虑可用性意味着在网络分区期间，MySQL 从节点可能会读取陈旧数据，因为无法保证读取中的分布式一致性。

### 4.9.2 读一致性

MySQL 从节点可以处理读任务，但它们可能跟不上 MySQL 主节点的步伐。这可能导致读一致性问题。

在分布式环境中，论文"Replicated Data Consistency Explained Through Baseball"[37]描述了各种类型的读操作一致性。以下是常见类型的读操作一致性的详细概述。

![](media/67cd5a65477ae19ad1e9ec5d821e474c.png)

图 4-67. 常见类型的读操作一致性。

该图描述了三种最常见的一致性类型：强一致性、读己所写一致性和最终一致性。观察到的模式是，一致性越强，性能越差，可用性越低。

当从多个 MySQL 从节点读取数据时，很容易出现各种一致性读问题。这些可以使用 MySQL 代理来缓解。例如，对于同一用户会话，读操作可以定向到单个 MySQL 从节点。如果该 MySQL 从节点上的数据不是最新的，操作将等待，从而避免典型的一致性读问题。

MySQL 已经做出了重大努力来确保集群环境中的一致读取。在 MySQL 从节点重放期间，保持事务提交顺序与中继日志条目顺序一致至关重要。这意味着事务只能在所有先前的事务都已提交后才能提交。MySQL 中的 **replica_preserve_commit_order** 参数有助于强制执行此约束。

为了有效缓解一致性读问题，MySQL 从节点理想情况下应该跟上 MySQL 主节点的步伐。如果 MySQL 主节点及其从节点以类似的速度运行，用户可以快速从从节点访问最新数据。因此，结合 MySQL 从节点上的快速重放和解决一致性读问题可以显著缓解这些挑战。

### 4.9.3 共识

几十年来，Paxos 算法一直是分布式共识的代名词。尽管其在生产系统中得到广泛部署，但 Paxos 经常被误解，并且在实践中被证明是重量级的、不可扩展的和不可靠的。已经进行了广泛的研究以更好地理解该算法、优化其性能并减轻其局限性[29]。随着时间的推移，出现了许多 Paxos 的变体，每个变体都根据基于多数的共识针对不同的应用场景进行了调整。重要的是要区分这些变体。

例如，MySQL 中的 Group Replication 支持单主和多主模式，在单主模式下需要一致的读写操作。这需要多领导者 Paxos 算法来达成共识。MySQL 原始的 Mencius 算法在某些场景中面临性能问题，导致引入单领导者 Multi-Paxos 算法来解决这些问题。同时维护两种不同的 Paxos 算法变体在代码维护方面构成挑战，后来发现的众多回归问题验证了这一观点。

### 4.9.4 分布式事务

在 MySQL 中，XA 协议可用于实现两阶段提交协议，确保分布式环境中的原子性。许多数据库产品使用 XA 来实现具有各种事务隔离级别的分布式事务。然而，这种情况下的响应时间通常不理想。

如"Designing Data-Intensive Applications"[28]中所强调的："XA 具有较差的容错性和性能特性，这严重限制了其实用性。"MySQL XA 事务不仅对响应时间产生负面影响，还对 MySQL 从节点重放构成挑战。XA 事务的第二阶段依赖于第一阶段，影响 MySQL 从节点上的并发重放，因为不同阶段必须串行进行。

因此，建议 MySQL 用户尽可能避免 XA 事务。重要的是要注意，虽然 XA 两阶段提交协议与 Paxos 算法有一些相似之处，但 XA 协议不能利用批处理技术，并且需要所有参与者同意才能继续进行后续操作。

[下一页](Chapter4_10_zh.md)
